C51 COMPILER V9.54   ________                                                              12/07/2023 09:00:32 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE ________
OBJECT MODULE PLACED IN .\Objects\◊ºøº÷§∫≈.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE ◊ºøº÷§∫≈.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\◊ºø
                    -º÷§∫≈.lst) OBJECT(.\Objects\◊ºøº÷§∫≈.obj)

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include "absacc.h"
   3          #include <stdio.h>
   4          #include "iic.h"
   5          #include "onewire.h"
   6          
   7          /////ÂáΩÊï∞Â£∞Êòé////
   8          void externaldevice_IO(unsigned char beepdata,unsigned char relaydata);//IOÊ®°ÂºèÔºåÊéßÂà∂Â§ñÈÉ®ËÆæÂ§áÔºàË
             -úÇÈ∏£Âô®„ÄÅÁªßÁîµÂô®Ôºâ
   9          void externaldevice_MM(unsigned char beepdata,unsigned char relaydata);//MMÊ®°ÂºèÔºåÊéßÂà∂Â§ñÈÉ®ËÆæÂ§áÔºàË
             -úÇÈ∏£Âô®„ÄÅÁªßÁîµÂô®Ôºâ
  10          void delay_ms(unsigned int delaydata);//Âª∂Êó∂ÂáΩÊï∞
  11          
  12          void LED_IO(unsigned char LEDdata);      //IOÊ®°ÂºèÔºåÊéßÂà∂LED
  13          void LED_MM(unsigned char LEDdata);      //MMÊ®°ÂºèÔºåÊéßÂà∂LED
  14          void timer1_init(void);                  //time1ÂÆöÊó∂ËÆ°Êï∞Âô®ÈÖçÁΩÆ‰∏∫1msÁöÑÂÆöÊó∂‰∏≠Êñ≠
  15          void display_IO(void);                   //Êï∞Á†ÅÁÆ°Âä®ÊÄÅÂà∑Êñ∞ÂáΩÊï∞
  16          void display_MM(void);                  //Êï∞Á†ÅÁÆ°Âä®ÊÄÅÂà∑Êñ∞ÂáΩÊï∞
  17          unsigned char BTN_KeyBoardScan(void);   //Áã¨Á´ãÊåâÈîÆÊâ´ÊèèÁ®ãÂ∫èÔºåÊó†ÊúâÊïàÊåâÈîÆÊåâ‰∏ãÊó∂ÔºåËøîÂõû0xFF
             -;ÊåâÈîÆÊåâ‰∏ãÔºåËøîÂõûÂØπÂ∫îÂ∫èÂè∑ÔºõÊåâÈîÆÈïøÊåâÊó∂ÔºåËøá‰∏ÄÊÆµÊó∂Èó¥ÔºåËøîÂõûÂØπÂ∫îÂ∫èÂè∑+10ÔºõÊùæÊâãÊó∂ÔºåËøîÂõûÂØπÂ∫
             -îÂ∫èÂè∑+20„ÄÇÔºà4567Ôºâ
  18          unsigned char KBD_KeyBoardScan(void);   //Áü©ÈòµÊåâÈîÆÊâ´ÊèèÁ®ãÂ∫èÔºåÊó†ÊúâÊïàÊåâÈîÆÊåâ‰∏ãÊó∂ÔºåËøîÂõû0xFF
             -;ÊåâÈîÆÊåâ‰∏ãÔºåËøîÂõûÂØπÂ∫îÂ∫èÂè∑ÔºõÊåâÈîÆÈïøÊåâÊó∂ÔºåËøá‰∏ÄÊÆµÊó∂Èó¥ÔºåËøîÂõûÂØπÂ∫îÂ∫èÂè∑+20ÔºõÊùæÊâãÊó∂ÔºåËøîÂõûÂØπÂ∫
             -îÂ∫èÂè∑+40„ÄÇÔºà4-19Ôºâ
  19          ////ÂÖ®Â±ÄÂèòÈáèÂÆö‰πâ//////
  20          unsigned int gTimer_1ms=0;  //ÂÖ®Â±ÄÂèòÈáèÔºåÁî®‰∫éËÆ°Êó∂
  21          bit gFlag_10ms;             //ÂÖ®Â±ÄÂèòÈáèÔºåÊØè10msÔºåËØ•ÂèòÈáèÁΩÆ1
  22          bit gFlag_50ms;             //ÂÖ®Â±ÄÂèòÈáèÔºåÊØè50msÔºåËØ•ÂèòÈáèÁΩÆ1
  23          bit gFlag_100ms;            //ÂÖ®Â±ÄÂèòÈáèÔºåÊØè100msÔºåËØ•ÂèòÈáèÁΩÆ1
  24          bit gFlag_200ms;            //ÂÖ®Â±ÄÂèòÈáèÔºåÊØè200msÔºåËØ•ÂèòÈáèÁΩÆ1
  25          bit gFlag_250ms;            //ÂÖ®Â±ÄÂèòÈáèÔºåÊØè250msÔºåËØ•ÂèòÈáèÁΩÆ1
  26          bit gFlag_1000ms;           //ÂÖ®Â±ÄÂèòÈáèÔºåÊØè1000msÔºåËØ•ÂèòÈáèÁΩÆ1
  27          unsigned char dispbuf[8] = {16,16,16,16,16,16,16,16}; //ÊòæÁ§∫ÁºìÂÜ≤Âå∫
  28          /*************  Êú¨Âú∞Â∏∏ÈáèÂ£∞Êòé    **************/
  29          unsigned char code disptab[]={                       //Ê†áÂáÜÂ≠óÂ∫ì(ÂÖ±Èò¥)
  30          //   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
  31              0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,
  32          //black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y
  33              0x00,0x40,0x76,0x1E,0x70,0x38,0x37,0x5C,0x73,0x3E,0x78,0x3d,0x67,0x50,0x37,0x6e,
  34             //0.   1.   2.  3.    4.    5.  6.   7.   8.    9.   -1 
  35              0xBF,0x86,0xDB,0xCF,0xE6,0xED,0xFD,0x87,0xFF,0xEF,0x46};
  36          
  37          ////////////DS18B20ÂèòÈáè//////////
  38          /*extern unsigned int Temp_Value;               //Â≠òÂÇ®Ê∏©Â∫¶ÂÄºÔºåÂÆûÈôÖÊ∏©Â∫¶ÁöÑ100ÂÄç
  39          extern unsigned char Temp_Symbol;               //Ê∏©Â∫¶ÂÄºÁ¨¶Âè∑Ôºå0Ê≠£1Ë¥ü
  40          extern float Temp_F;*/
  41          
  42          
  43          ///‰∏ªÂáΩÊï∞//////
  44          void main()
  45          {
  46   1        unsigned char i=0;
  47   1        unsigned char key_value = 0xFF;
  48   1        unsigned char AD1_value_Now = 0;
C51 COMPILER V9.54   ________                                                              12/07/2023 09:00:32 PAGE 2   

  49   1        unsigned char AD3_value_Now = 0;
  50   1      
  51   1        externaldevice_IO(0,0);
  52   1        LED_IO(0XFF);   //ÁÅ≠ÁÅØ
  53   1        timer1_init();
  54   1      
  55   1        //Ê∏©Â∫¶‰º†ÊÑüÂô®
  56   1        while(1)
  57   1        {
  58   2          if(gFlag_200ms)
  59   2          {
  60   3            gFlag_200ms = 0;
  61   3            rd_temperature();
  62   3            if(Temp_Value>=1000)  dispbuf[0] = Temp_Value%10000/1000;
  63   3            else dispbuf[0] = 16;
  64   3            dispbuf[1] = Temp_Value%1000/100 + 32; //ÊòæÁ§∫Â∞èÊï∞ÁÇπ
  65   3            dispbuf[2] = Temp_Value%100/10;
  66   3            dispbuf[3] = Temp_Value%10;
  67   3            ADC_PCF8591(0x01);
  68   3            ADC_PCF8591(0x01);
  69   3            AD1_value_Now = ADC_PCF8591(0x01);
  70   3            dispbuf[5] = AD1_value_Now/100;
  71   3            dispbuf[6] = AD1_value_Now%100/10;
  72   3            dispbuf[7] = AD1_value_Now%10;
  73   3      
  74   3          } 
  75   2        }
  76   1      
  77   1        //ADDA
  78   1        while(1)
  79   1        {
  80   2          if(gFlag_200ms)
  81   2          {
  82   3            gFlag_200ms = 0;
  83   3            ADC_PCF8591(0x01);
  84   3            ADC_PCF8591(0x01);
  85   3            AD1_value_Now = ADC_PCF8591(0x01);
  86   3            dispbuf[0] = AD1_value_Now/100;
  87   3            dispbuf[1] = AD1_value_Now%100/10;
  88   3            dispbuf[2] = AD1_value_Now%10;
  89   3            ADC_PCF8591(0x03);
  90   3            ADC_PCF8591(0x03);
  91   3            AD3_value_Now = ADC_PCF8591(0x03);
  92   3            dispbuf[5] = AD3_value_Now/100;
  93   3            dispbuf[6] = AD3_value_Now%100/10;
  94   3            dispbuf[7] = AD3_value_Now%10;
  95   3            DAC_PCF8591(AD3_value_Now);
  96   3          } 
  97   2        }
  98   1      
  99   1      
 100   1      
 101   1      
 102   1      //I2C‰ªªÂä°
 103   1        EA = 0;
 104   1        i = read_EEPROM(0x00);
 105   1        if(i>=100)  dispbuf[5] = i/100;
 106   1        else dispbuf[5] = 16;
 107   1        if(i >= 10) dispbuf[6] = i%100/10;
 108   1        else dispbuf[6] = 16;
 109   1        dispbuf[7] = i%10;
 110   1        i++;
C51 COMPILER V9.54   ________                                                              12/07/2023 09:00:32 PAGE 3   

 111   1        write_EEPROM(0x00,i);
 112   1        EA = 1;
 113   1        while(1);
 114   1      
 115   1      
 116   1      //Áã¨Á´ãÊåâÈîÆ‰ªªÂä°
 117   1        while(1)
 118   1        {
 119   2          if(gFlag_10ms)
 120   2          {
 121   3            gFlag_10ms = 0;
 122   3            key_value = KBD_KeyBoardScan();
 123   3          }
 124   2          if(key_value != 0xFF)
 125   2          {
 126   3            dispbuf[0] = key_value/10;
 127   3            dispbuf[1] = key_value%10;
 128   3            switch(key_value)
 129   3            {
 130   4              case 7:i++; break;
 131   4              case 11:i--; break;
 132   4              case 15:i += 2; break;
 133   4              case 19:i -= 2; break;
 134   4              default:break;
 135   4            }
 136   3            key_value = 0xFF;
 137   3            dispbuf[5] = i/100;
 138   3            dispbuf[6] = i%100/10;
 139   3            dispbuf[7] = i%10;
 140   3          }
 141   2        }
 142   1      
 143   1        //ÂÆûÁé∞Êï∞Á†ÅÁÆ°ÊòæÁ§∫12345678
 144   1        dispbuf[0] = 1;
 145   1        dispbuf[1] = 2;
 146   1        dispbuf[2] = 3;
 147   1        dispbuf[3] = 4;
 148   1        dispbuf[4] = 5;
 149   1        dispbuf[5] = 6;
 150   1        dispbuf[6] = 7;
 151   1        dispbuf[7] = 8;
 152   1        //ÂÆûÁé∞LEDÁßíÈó™ÁÉÅ
 153   1        while(1)
 154   1        {
 155   2          if(gFlag_1000ms)
 156   2          {
 157   3            gFlag_1000ms = 0;
 158   3            LED_IO(i); //LEDÂÖ®‰∫ÆÊàñÂÖ®ÁÅ≠
 159   3            i = ~i;
 160   3          }
 161   2          
 162   2        }
 163   1      }
 164          ////////////////////////////////
 165          void externaldevice_IO(unsigned char beepdata,unsigned char relaydata)//IOÊ®°ÂºèÔºåÊéßÂà∂Â§ñÈÉ®ËÆæÂ§áÔºàËú
             -ÇÈ∏£Âô®„ÄÅÁªßÁîµÂô®Ôºâ
 166          {
 167   1        unsigned char extdev_data=0;
 168   1        if(beepdata) extdev_data|=0X40;
 169   1        if(relaydata) extdev_data|=0X10;
 170   1        EA = 0;//ÂÖ≥Èó≠‰∏≠Êñ≠ÊÄª‰ΩøËÉΩ
 171   1        P0 = extdev_data;
C51 COMPILER V9.54   ________                                                              12/07/2023 09:00:32 PAGE 4   

 172   1        P2 = (P2 & 0X1F)|0XA0;//0b 101X XXXX ‰Ωø138ËØëÁ†ÅËæìÂÖ•CBA‰∏∫5ÔºåY5ËæìÂá∫‰ΩéÁîµÂπ≥Ôºå573ÁöÑLE‰∏∫È´òÈîÅÂ≠
             -òÁä∂ÊÄÅËß£Èô§
 173   1        P0 = extdev_data;
 174   1        P2 &= 0X1F;//0b 000X XXXX //ÈîÅÂ≠òÊï∞ÊçÆ
 175   1        EA = 1;//ÊâìÂºÄ‰∏≠Êñ≠ÊÄª‰ΩøËÉΩ
 176   1      }
 177          ////////////////////////////////
 178          void externaldevice_MM(unsigned char beepdata,unsigned char relaydata)//MMÊ®°ÂºèÔºåÊéßÂà∂Â§ñÈÉ®ËÆæÂ§áÔºàËú
             -ÇÈ∏£Âô®„ÄÅÁªßÁîµÂô®Ôºâ
 179          {
 180   1        unsigned char extdev_data=0;
 181   1        if(beepdata) extdev_data|=0X40;
 182   1        if(relaydata) extdev_data|=0X10;
 183   1        EA = 0;//ÂÖ≥Èó≠‰∏≠Êñ≠ÊÄª‰ΩøËÉΩ
 184   1        XBYTE[0XA000] = extdev_data;
 185   1        P2 &= 0X1F;//0b 000X XXXX //ÈîÅÂ≠òÊï∞ÊçÆ
 186   1        EA = 1;//ÊâìÂºÄ‰∏≠Êñ≠ÊÄª‰ΩøËÉΩ
 187   1      }
 188          ////////////////////////////////
 189          void delay_ms(unsigned int delaydata)//Âª∂Êó∂ÂáΩÊï∞
 190          {
 191   1        unsigned int i;
 192   1        while(delaydata--)
 193   1          for(i=640;i>0;i--);
 194   1      }
 195          
 196          /////////////////////////////
 197          void LED_IO(unsigned char LEDdata)//IOÊ®°ÂºèÔºåÊéßÂà∂LED
 198          {
 199   1        
 200   1        EA = 0;//ÂÖ≥Èó≠‰∏≠Êñ≠ÊÄª‰ΩøËÉΩ
 201   1        P0 = LEDdata;
 202   1        P2 = (P2 & 0X1F)|0X80;//0b 100X XXXX ‰Ωø138ËØëÁ†ÅËæìÂÖ•CBA‰∏∫5ÔºåY5ËæìÂá∫‰ΩéÁîµÂπ≥Ôºå573ÁöÑLE‰∏∫È´òÈîÅÂ≠
             -òÁä∂ÊÄÅËß£Èô§
 203   1        P0 = LEDdata;
 204   1        P2 &= 0X1F;//0b 000X XXXX //ÈîÅÂ≠òÊï∞ÊçÆ
 205   1        EA = 1;//ÊâìÂºÄ‰∏≠Êñ≠ÊÄª‰ΩøËÉΩ
 206   1      }
 207          
 208          void LED_MM(unsigned char LEDdata)//MMÊ®°ÂºèÔºåÊéßÂà∂LED
 209          {
 210   1        EA = 0;//ÂÖ≥Èó≠‰∏≠Êñ≠ÊÄª‰ΩøËÉΩ
 211   1        XBYTE[0X8000] = LEDdata;
 212   1        P2 &= 0X1F;//0b 000X XXXX //ÈîÅÂ≠òÊï∞ÊçÆ
 213   1        EA = 1;//ÊâìÂºÄ‰∏≠Êñ≠ÊÄª‰ΩøËÉΩ
 214   1      }
 215          
 216          /////////////////////////////
 217          void timer1_init(void)         //time1ÂÆöÊó∂ËÆ°Êï∞Âô®ÈÖçÁΩÆ‰∏∫1msÁöÑÂÆöÊó∂‰∏≠Êñ≠
 218          {
 219   1              AUXR &= 0xBF;           //ÂÆöÊó∂Âô®Êó∂Èíü12TÊ®°Âºè
 220   1              TMOD &= 0x0F;           //ËÆæÁΩÆÂÆöÊó∂Âô®Ê®°Âºè
 221   1              TL1 = 0x18;             //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
 222   1              TH1 = 0xFC;             //ËÆæÁΩÆÂÆöÊó∂ÂàùÂßãÂÄº
 223   1              TF1 = 0;                //Ê∏ÖÈô§TF1Ê†áÂøó
 224   1              TR1 = 1;                //ÂÆöÊó∂Âô®1ÂºÄÂßãËÆ°Êó∂
 225   1        ET1 = 1;        //time1‰∏≠Êñ≠ÂàÜÂÖÅËÆ∏
 226   1        EA = 1;         //‰∏≠Êñ≠ÊÄªÂÖÅËÆ∏
 227   1      }
 228          
 229          void tm1_isr() interrupt 3
 230          {
C51 COMPILER V9.54   ________                                                              12/07/2023 09:00:32 PAGE 5   

 231   1        gTimer_1ms++;
 232   1        if(gTimer_1ms == 60000)    gTimer_1ms=0;
 233   1        if(gTimer_1ms%10 == 0)    gFlag_10ms=1;
 234   1        if(gTimer_1ms%50 == 0)    gFlag_50ms=1;
 235   1        if(gTimer_1ms%100 == 0)   gFlag_100ms=1;
 236   1        if(gTimer_1ms%200 == 0)   gFlag_200ms=1;
 237   1        if(gTimer_1ms%250 == 0)   gFlag_250ms=1;
 238   1        if(gTimer_1ms%1000 == 0)  gFlag_1000ms=1;
 239   1        display_IO();
 240   1        for(Temp_Value;Temp_Value>7500;rd_temperature());
 241   1        
 242   1        
 243   1      }
 244          //////////////////////////////////////////////////
 245          void display_IO(void)
 246          {
 247   1        static unsigned char dispcom_IO = 0;
 248   1      
 249   1        P0 = 0xFF; //‰ΩøÊÆµÈÄâÂÖ®ÈÉ®ËæìÂá∫‰∏∫È´òÔºå‰ªéËÄå‰ΩøÊâÄÊúâÊï∞Á†ÅÁÆ°Ê∂àÈöê
 250   1        P2 = (P2 & 0x1F)|0XE0;//0b 111X XXXX ‰Ωø138ËØëÁ†ÅËæìÂÖ•CBA‰∏∫7ÔºåY7ËæìÂá∫‰ΩéÁîµÂπ≥ÔºåÊÆµÈÄâ573ÁöÑLE‰∏∫È´
             -òÔºåÈîÅÂ≠òÁä∂ÊÄÅËß£Èô§
 251   1        P2 &= 0x1F;//0b 000X XXXX //ÈîÅÂ≠òÊï∞ÊçÆ
 252   1        P0 = 0;
 253   1        //‰ΩçÈÄâ
 254   1        P2 = (P2 & 0X1F)|0XC0;//0b 110X XXXX ‰Ωø138ËØëÁ†ÅËæìÂÖ•CBA‰∏∫6ÔºåY6ËæìÂá∫‰ΩéÁîµÂπ≥Ôºå‰ΩçÈÄâ573ÁöÑLE‰∏∫È´
             -òÔºåÈîÅÂ≠òÁä∂ÊÄÅËß£Èô§
 255   1        P0 = 1<<dispcom_IO;
 256   1        P2 &= 0X1F;//0b 000X XXXX //ÈîÅÂ≠òÊï∞ÊçÆ
 257   1        //ÊÆµÈÄâ
 258   1        P0 = 0xFF;
 259   1        P2 = (P2 & 0X1F)|0XE0;//0b 111X XXXX ‰Ωø138ËØëÁ†ÅËæìÂÖ•CBA‰∏∫7ÔºåY7ËæìÂá∫‰ΩéÁîµÂπ≥ÔºåÊÆµÈÄâ573ÁöÑLE‰∏∫È´
             -òÔºåÈîÅÂ≠òÁä∂ÊÄÅËß£Èô§
 260   1        P0 = ~disptab[dispbuf[dispcom_IO]];
 261   1        P2 &= 0x1F;//0b 000X XXXX //ÈîÅÂ≠òÊï∞ÊçÆ
 262   1      
 263   1        dispcom_IO++;
 264   1        if (dispcom_IO >= 8) dispcom_IO = 0;
 265   1      }
 266          void display_MM(void)
 267          {
 268   1        EA = 0;//ÂÖ≥Èó≠‰∏≠Êñ≠ÊÄª‰ΩøËÉΩ
 269   1        XBYTE[0X8000] = 0;
 270   1        P2 &= 0X1F;//0b 000X XXXX //ÈîÅÂ≠òÊï∞ÊçÆ
 271   1        EA = 1;//ÊâìÂºÄ‰∏≠Êñ≠ÊÄª‰ΩøËÉΩ
 272   1      }
 273          
 274          /////////////////////////////////
 275          unsigned char BTN_KeyBoardScan(void)   //Áã¨Á´ãÊåâÈîÆÊâ´ÊèèÁ®ãÂ∫èÔºåÊó†ÊúâÊïàÊåâÈîÆÊåâ‰∏ãÊó∂ÔºåËøîÂõû0xFF;
             -ÊåâÈîÆÊåâ‰∏ãÔºåËøîÂõûÂØπÂ∫îÂ∫èÂè∑ÔºõÊåâÈîÆÈïøÊåâÊó∂ÔºåÊØèËøá‰∏ÄÊÆµÊó∂Èó¥ÔºåËøîÂõûÂØπÂ∫îÂ∫èÂè∑+10ÔºõÊùæÊâãÊó∂ÔºåËøîÂõûÂØπ
             -Â∫îÂ∫èÂè∑+20„ÄÇ
 276          {
 277   1        static unsigned char KeyPressBTN = 0; //Â≠òÂÇ®ÊåâÈîÆÊåâÂéãÊó∂Èïø
 278   1        static unsigned char KeyFreeBTN = 0;  //ÊåâÈîÆÊùæÂºÄÊ†áÂøó
 279   1        static unsigned char KeyValueBTN = 0; //Â≠òÂÇ®ÊåâÈîÆÈîÆÂÄº
 280   1        static unsigned char IntervalBTN = 55; //Â≠òÂÇ®ÈïøÊåâÈîÆÊó∂ÔºåÈîÆÂÄºËøîÂõûÁöÑÊó∂Èó¥Èó¥ÈöîÔºå550ms
 281   1        unsigned char temp;
 282   1        P3 |= 0x0F;
 283   1        temp = (P3 & 0x0F);
 284   1        if(temp != 0x0F) //ÊòØÂê¶ÊúâÈîÆË¢´Êåâ‰∏ã
 285   1        {
 286   2          if(KeyPressBTN < 200) KeyPressBTN++;
 287   2          if(KeyPressBTN < 5)
C51 COMPILER V9.54   ________                                                              12/07/2023 09:00:32 PAGE 6   

 288   2          {
 289   3            return 0xFF;
 290   3          }
 291   2          else if(KeyPressBTN == 5)
 292   2          {
 293   3            KeyFreeBTN = 1;
 294   3            IntervalBTN = 55;
 295   3            switch(temp)
 296   3            {
 297   4              case 0x0E:KeyValueBTN = 7;break;
 298   4              case 0x0D:KeyValueBTN = 6;break;
 299   4              case 0x0B:KeyValueBTN = 5;break;
 300   4              case 0x07:KeyValueBTN = 4;break;
 301   4              //Â¶ÇÊûúÈúÄË¶ÅÁªÑÂêàÈîÆÔºåÂèØÊ†πÊçÆÈîÆÂÄºÂ¢ûÂä†ÊÉÖÂÜµ
 302   4              default:KeyValueBTN = 0xFF; KeyFreeBTN = 0;IntervalBTN = 0;KeyPressBTN = 0;break;
 303   4            }
 304   3            return KeyValueBTN;
 305   3          }
 306   2          else //Â§ÑÁêÜÈïøÊåâÈîÆ
 307   2          {
 308   3            if(IntervalBTN)
 309   3            {
 310   4              IntervalBTN--;
 311   4              if(IntervalBTN == 0)
 312   4              {
 313   5                IntervalBTN = 55;
 314   5                return KeyValueBTN+10;
 315   5              }
 316   4            }
 317   3            else IntervalBTN = 55;
 318   3            return 0xFF;
 319   3          }
 320   2        }
 321   1        else //Êó†ÈîÆÊåâ‰∏ãÊàñÂ∑≤ÈáäÊîæ
 322   1        {
 323   2          KeyPressBTN = 0;
 324   2          if(KeyFreeBTN == 1)
 325   2          {
 326   3            KeyFreeBTN = 0;
 327   3            return KeyValueBTN+20;
 328   3          }
 329   2          return 0xFF;
 330   2        }
 331   1      }
 332          //////////////////////////////////////
 333          unsigned char KBD_KeyBoardScan(void)  //Áü©ÈòµÊåâÈîÆÊâ´ÊèèÁ®ãÂ∫èÔºåÊó†ÊúâÊïàÊåâÈîÆÊåâ‰∏ãÊó∂ÔºåËøîÂõû0xFF;Ê
             -åâÈîÆÊåâ‰∏ãÔºåËøîÂõûÂØπÂ∫îÂ∫èÂè∑ÔºõÊåâÈîÆÈïøÊåâÊó∂ÔºåËøá‰∏ÄÊÆµÊó∂Èó¥ÔºåËøîÂõûÂØπÂ∫îÂ∫èÂè∑+20ÔºõÊùæÊâãÊó∂ÔºåËøîÂõûÂØπÂ∫îÂ
             -∫èÂè∑+40„ÄÇÔºà4-19)
 334          {
 335   1        static unsigned char KeyPressKBD = 0; //Â≠òÂÇ®ÊåâÈîÆÊåâÂéãÊó∂Èïø
 336   1        static unsigned char KeyFreeKBD = 0;  //ÊåâÈîÆÊùæÂºÄÊ†áÂøó
 337   1        static unsigned char KeyValueKBD = 0; //Â≠òÂÇ®ÊåâÈîÆÈîÆÂÄº
 338   1        static unsigned char IntervalKBD = 55; //Â≠òÂÇ®ÈïøÊåâÈîÆÊó∂ÔºåÈîÆÂÄºËøîÂõûÁöÑÊó∂Èó¥Èó¥ÈöîÔºå550ms
 339   1        unsigned char S1;
 340   1        unsigned char S2;
 341   1        P3 = 0x0F;
 342   1        P42 = 0;
 343   1        P44 = 0;
 344   1        S1 = (P3 & 0x0F);
 345   1        if(S1 != 0x0F) //ÊúâÈîÆË¢´Êåâ‰∏ã
 346   1        {
 347   2          if(KeyPressKBD < 200) KeyPressKBD++;
C51 COMPILER V9.54   ________                                                              12/07/2023 09:00:32 PAGE 7   

 348   2          if(KeyPressKBD < 5)
 349   2          {
 350   3            return 0xFF;
 351   3          }
 352   2          else if(KeyPressKBD == 5)
 353   2          {
 354   3            KeyFreeKBD = 1;
 355   3            IntervalKBD = 55;
 356   3            S1 = (P3 & 0x0F);
 357   3            P3 = 0xF0;
 358   3            P42 = 1;
 359   3            P44 = 1;
 360   3            S2 = (P3 & 0xF0);
 361   3            if(P42) S2 |= 0x40;
 362   3            else S2 &= (~0x40);
 363   3            if(P44) S2 |= 0x80;
 364   3            else S2 &= (~0x80);
 365   3            S1 |= S2;
 366   3      
 367   3            switch(S1)
 368   3            {
 369   4              case 0x77:KeyValueKBD = 4;break;
 370   4              case 0x7B:KeyValueKBD = 5;break;
 371   4              case 0x7D:KeyValueKBD = 6;break;
 372   4              case 0x7E:KeyValueKBD = 7;break;
 373   4              case 0xB7:KeyValueKBD = 8;break;
 374   4              case 0xBB:KeyValueKBD = 9;break;
 375   4              case 0xBD:KeyValueKBD = 10;break;
 376   4              case 0xBE:KeyValueKBD = 11;break;
 377   4              case 0xD7:KeyValueKBD = 12;break;
 378   4              case 0xDB:KeyValueKBD = 13;break;
 379   4              case 0xDD:KeyValueKBD = 14;break;
 380   4              case 0xDE:KeyValueKBD = 15;break;
 381   4              case 0xE7:KeyValueKBD = 16;break;
 382   4              case 0xEB:KeyValueKBD = 17;break;
 383   4              case 0xED:KeyValueKBD = 18;break;
 384   4              case 0xEE:KeyValueKBD = 19;break;
 385   4              //Â¶ÇÊûúÈúÄË¶ÅÁªÑÂêàÈîÆÔºåÂèØÊ†πÊçÆÈîÆÂÄºÂ¢ûÂä†ÊÉÖÂÜµ
 386   4              default:KeyValueKBD = 0xFF; KeyFreeKBD = 0;IntervalKBD = 0;KeyPressKBD = 0;break;
 387   4            }
 388   3            return KeyValueKBD;
 389   3          }
 390   2          else //Â§ÑÁêÜÈïøÊåâÈîÆ
 391   2          {
 392   3            if(IntervalKBD)
 393   3            {
 394   4              IntervalKBD--;
 395   4              if(IntervalKBD == 0)
 396   4              {
 397   5                IntervalKBD = 55;
 398   5                return KeyValueKBD+20;
 399   5              }
 400   4            }
 401   3            else IntervalKBD = 55;
 402   3            return 0xFF;
 403   3          }
 404   2        }
 405   1        else //Êó†ÈîÆÊåâ‰∏ãÊàñÂ∑≤ÈáäÊîæ
 406   1        {
 407   2          KeyPressKBD = 0;
 408   2          if(KeyFreeKBD == 1)
 409   2          {
C51 COMPILER V9.54   ________                                                              12/07/2023 09:00:32 PAGE 8   

 410   3            KeyFreeKBD = 0;
 411   3            return KeyValueKBD+40;
 412   3          }
 413   2          return 0xFF;
 414   2        }
 415   1      }
*** WARNING C294 IN LINE 103 OF ◊ºøº÷§∫≈.c: unreachable code
*** WARNING C294 IN LINE 144 OF ◊ºøº÷§∫≈.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1059    ----
   CONSTANT SIZE    =     43    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
