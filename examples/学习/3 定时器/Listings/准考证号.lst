C51 COMPILER V9.54   ________                                                              08/07/2023 00:25:55 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE ________
OBJECT MODULE PLACED IN .\Objects\׼֤.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE ׼֤.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\׼
                    -֤.lst) OBJECT(.\Objects\׼֤.obj)

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include "absacc.h"
   3          #include <stdio.h>
   4          
   5          /////函数声明////
   6          void externaldevice_IO(unsigned char beepdata,unsigned char relaydata);//IO模式，控制外部设备（
             -鸣器、继电器）
   7          void externaldevice_MM(unsigned char beepdata,unsigned char relaydata);//MM模式，控制外部设备（
             -鸣器、继电器）
   8          void delay_ms(unsigned int delaydata);//延时函数
   9          
  10          void LED_IO(unsigned char LEDdata); //IO模式，控制LED
  11          void LED_MM(unsigned char LEDdata); //MM模式，控制LED
  12          void timer1_init(void);             //time1定时计数器配置为1ms的定时中断
  13          
  14          ////全局变量定义//////
  15          unsigned int gTimer_1ms=0;  //全局变量，用于计时
  16          bit gFlag_10ms;             //全局变量，每10ms，该变量置1
  17          bit gFlag_50ms;             //全局变量，每10ms，该变量置1
  18          bit gFlag_100ms;            //全局变量，每10ms，该变量置1
  19          bit gFlag_200ms;            //全局变量，每10ms，该变量置1
  20          bit gFlag_250ms;            //全局变量，每10ms，该变量置1
  21          bit gFlag_1000ms;           //全局变量，每10ms，该变量置1
  22          
  23          
  24          ///主函数//////
  25          void main()
  26          {
  27   1        unsigned char i=0;
  28   1        externaldevice_IO(0,0);
  29   1        LED_IO(0XFF);   //灭灯
  30   1        timer1_init();
  31   1      
  32   1        //实现LED秒闪烁
  33   1        while(1)
  34   1        {
  35   2          if(gFlag_1000ms)
  36   2          {
  37   3            gFlag_1000ms = 0;
  38   3            LED_IO(i); //LED全亮或全灭
  39   3            i = ~i;
  40   3          }
  41   2          
  42   2        }
  43   1      }
  44          ////////////////////////////////
  45          void externaldevice_IO(unsigned char beepdata,unsigned char relaydata)//IO模式，控制外部设备（
             -鸣器、继电器）
  46          {
  47   1        unsigned char extdev_data=0;
  48   1        if(beepdata) extdev_data|=0X40;
  49   1        if(relaydata) extdev_data|=0X10;
  50   1        EA = 0;//关闭中断总使能
  51   1        P0 = extdev_data;
C51 COMPILER V9.54   ________                                                              08/07/2023 00:25:55 PAGE 2   

  52   1        P2 = (P2 & 0X1F)|0XA0;//0b 101X XXXX 使138译码输入CBA为5，Y5输出低电平，573的LE为高锁
             -状态解除
  53   1        P0 = extdev_data;
  54   1        P2 &= 0X1F;//0b 000X XXXX //锁存数据
  55   1        EA = 1;//打开中断总使能
  56   1      }
  57          ////////////////////////////////
  58          void externaldevice_MM(unsigned char beepdata,unsigned char relaydata)//MM模式，控制外部设备（
             -鸣器、继电器）
  59          {
  60   1        unsigned char extdev_data=0;
  61   1        if(beepdata) extdev_data|=0X40;
  62   1        if(relaydata) extdev_data|=0X10;
  63   1        EA = 0;//关闭中断总使能
  64   1        XBYTE[0XA000] = extdev_data;
  65   1        P2 &= 0X1F;//0b 000X XXXX //锁存数据
  66   1        EA = 1;//打开中断总使能
  67   1      }
  68          ////////////////////////////////
  69          void delay_ms(unsigned int delaydata)//延时函数
  70          {
  71   1        unsigned int i;
  72   1        while(delaydata--)
  73   1          for(i=640;i>0;i--);
  74   1      }
  75          
  76          /////////////////////////////
  77          void LED_IO(unsigned char LEDdata)//IO模式，控制LED
  78          {
  79   1        
  80   1        EA = 0;//关闭中断总使能
  81   1        P0 = LEDdata;
  82   1        P2 = (P2 & 0X1F)|0X80;//0b 100X XXXX 使138译码输入CBA为5，Y5输出低电平，573的LE为高锁
             -状态解除
  83   1        P0 = LEDdata;
  84   1        P2 &= 0X1F;//0b 000X XXXX //锁存数据
  85   1        EA = 1;//打开中断总使能
  86   1      }
  87          
  88          void LED_MM(unsigned char LEDdata)//MM模式，控制LED
  89          {
  90   1        EA = 0;//关闭中断总使能
  91   1        XBYTE[0X8000] = LEDdata;
  92   1        P2 &= 0X1F;//0b 000X XXXX //锁存数据
  93   1        EA = 1;//打开中断总使能
  94   1      }
  95          
  96          /////////////////////////////
  97          void timer1_init(void)         //time1定时计数器配置为1ms的定时中断
  98          {
  99   1              AUXR &= 0xBF;           //定时器时钟12T模式
 100   1              TMOD &= 0x0F;           //设置定时器模式
 101   1              TL1 = 0x18;             //设置定时初始值
 102   1              TH1 = 0xFC;             //设置定时初始值
 103   1              TF1 = 0;                //清除TF1标志
 104   1              TR1 = 1;                //定时器1开始计时
 105   1        ET1 = 1;        //time1中断分允许
 106   1        EA = 1;         //中断总允许
 107   1      }
 108          
 109          void tm1_isr() interrupt 3
 110          {
C51 COMPILER V9.54   ________                                                              08/07/2023 00:25:55 PAGE 3   

 111   1        gTimer_1ms++;
 112   1        if(gTimer_1ms == 60000)    gTimer_1ms=0;
 113   1        if(gTimer_1ms%10 == 0)    gFlag_10ms=1;
 114   1        if(gTimer_1ms%50 == 0)    gFlag_50ms=1;
 115   1        if(gTimer_1ms%100 == 0)   gFlag_100ms=1;
 116   1        if(gTimer_1ms%200 == 0)   gFlag_200ms=1;
 117   1        if(gTimer_1ms%250 == 0)   gFlag_250ms=1;
 118   1        if(gTimer_1ms%1000 == 0)  gFlag_1000ms=1;
 119   1      }
 120          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    363    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
