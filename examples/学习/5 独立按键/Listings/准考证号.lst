C51 COMPILER V9.54   ________                                                              08/10/2023 18:29:07 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE ________
OBJECT MODULE PLACED IN .\Objects\×¼¿¼Ö¤ºÅ.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE ×¼¿¼Ö¤ºÅ.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\×¼¿
                    -¼Ö¤ºÅ.lst) OBJECT(.\Objects\×¼¿¼Ö¤ºÅ.obj)

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include "absacc.h"
   3          #include <stdio.h>
   4          
   5          /////å‡½æ•°å£°æ˜////
   6          void externaldevice_IO(unsigned char beepdata,unsigned char relaydata);//IOæ¨¡å¼ï¼Œæ§åˆ¶å¤–éƒ¨è®¾å¤‡ï¼ˆè
             -œ‚é¸£å™¨ã€ç»§ç”µå™¨ï¼‰
   7          void externaldevice_MM(unsigned char beepdata,unsigned char relaydata);//MMæ¨¡å¼ï¼Œæ§åˆ¶å¤–éƒ¨è®¾å¤‡ï¼ˆè
             -œ‚é¸£å™¨ã€ç»§ç”µå™¨ï¼‰
   8          void delay_ms(unsigned int delaydata);//å»¶æ—¶å‡½æ•°
   9          
  10          void LED_IO(unsigned char LEDdata);      //IOæ¨¡å¼ï¼Œæ§åˆ¶LED
  11          void LED_MM(unsigned char LEDdata);      //MMæ¨¡å¼ï¼Œæ§åˆ¶LED
  12          void timer1_init(void);                  //time1å®šæ—¶è®¡æ•°å™¨é…ç½®ä¸º1msçš„å®šæ—¶ä¸­æ–­
  13          void display_IO(void);                   //æ•°ç ç®¡åŠ¨æ€åˆ·æ–°å‡½æ•°
  14          void display_MM(void);                  //æ•°ç ç®¡åŠ¨æ€åˆ·æ–°å‡½æ•°
  15          unsigned char BTN_KeyBoardScan(void);   //ç‹¬ç«‹æŒ‰é”®æ‰«æç¨‹åºï¼Œæ— æœ‰æ•ˆæŒ‰é”®æŒ‰ä¸‹æ—¶ï¼Œè¿”å›0xFF
             -;æŒ‰é”®æŒ‰ä¸‹ï¼Œè¿”å›å¯¹åº”åºå·ï¼›æŒ‰é”®é•¿æŒ‰æ—¶ï¼Œæ¯è¿‡ä¸€æ®µæ—¶é—´ï¼Œè¿”å›å¯¹åº”åºå·+10ï¼›æ¾æ‰‹æ—¶ï¼Œè¿”å›å¯
             -¹åº”åºå·+20ã€‚
  16          
  17          ////å…¨å±€å˜é‡å®šä¹‰//////
  18          unsigned int gTimer_1ms=0;  //å…¨å±€å˜é‡ï¼Œç”¨äºè®¡æ—¶
  19          bit gFlag_10ms;             //å…¨å±€å˜é‡ï¼Œæ¯10msï¼Œè¯¥å˜é‡ç½®1
  20          bit gFlag_50ms;             //å…¨å±€å˜é‡ï¼Œæ¯50msï¼Œè¯¥å˜é‡ç½®1
  21          bit gFlag_100ms;            //å…¨å±€å˜é‡ï¼Œæ¯100msï¼Œè¯¥å˜é‡ç½®1
  22          bit gFlag_200ms;            //å…¨å±€å˜é‡ï¼Œæ¯200msï¼Œè¯¥å˜é‡ç½®1
  23          bit gFlag_250ms;            //å…¨å±€å˜é‡ï¼Œæ¯250msï¼Œè¯¥å˜é‡ç½®1
  24          bit gFlag_1000ms;           //å…¨å±€å˜é‡ï¼Œæ¯1000msï¼Œè¯¥å˜é‡ç½®1
  25          unsigned char dispbuf[8] = {16,16,16,16,16,16,16,16}; //æ˜¾ç¤ºç¼“å†²åŒº
  26          /*************  æœ¬åœ°å¸¸é‡å£°æ˜    **************/
  27          unsigned char code disptab[]={                       //æ ‡å‡†å­—åº“(å…±é˜´)
  28          //   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
  29              0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,
  30          //black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y
  31              0x00,0x40,0x76,0x1E,0x70,0x38,0x37,0x5C,0x73,0x3E,0x78,0x3d,0x67,0x50,0x37,0x6e,
  32             //0.   1.   2.  3.    4.    5.  6.   7.   8.    9.   -1 
  33              0xBF,0x86,0xDB,0xCF,0xE6,0xED,0xFD,0x87,0xFF,0xEF,0x46};
  34          
  35          
  36          
  37          ///ä¸»å‡½æ•°//////
  38          void main()
  39          {
  40   1        unsigned char i=0;
  41   1        unsigned char key_value = 0xFF;
  42   1        externaldevice_IO(0,0);
  43   1        LED_IO(0XFF);   //ç­ç¯
  44   1        timer1_init();
  45   1      //ç‹¬ç«‹æŒ‰é”®ä»»åŠ¡
  46   1        while(1)
  47   1        {
  48   2          if(gFlag_10ms)
  49   2          {
  50   3            gFlag_10ms = 0;
C51 COMPILER V9.54   ________                                                              08/10/2023 18:29:07 PAGE 2   

  51   3            key_value = BTN_KeyBoardScan();
  52   3          }
  53   2          if(key_value != 0xFF)
  54   2          {
  55   3            dispbuf[0] = key_value/10;
  56   3            dispbuf[1] = key_value%10;
  57   3            switch(key_value)
  58   3            {
  59   4              case 4:externaldevice_IO(0,0); break;
  60   4              case 5:externaldevice_IO(1,1); break;
  61   4              case 6:LED_IO(0xFF); break;
  62   4              case 7:LED_IO(0x00); break;
  63   4              default:break;
  64   4            }
  65   3            key_value = 0xFF;
  66   3          }
  67   2        }
  68   1      
  69   1        //å®ç°æ•°ç ç®¡æ˜¾ç¤º12345678
  70   1        dispbuf[0] = 1;
  71   1        dispbuf[1] = 2;
  72   1        dispbuf[2] = 3;
  73   1        dispbuf[3] = 4;
  74   1        dispbuf[4] = 5;
  75   1        dispbuf[5] = 6;
  76   1        dispbuf[6] = 7;
  77   1        dispbuf[7] = 8;
  78   1        //å®ç°LEDç§’é—ªçƒ
  79   1        while(1)
  80   1        {
  81   2          if(gFlag_1000ms)
  82   2          {
  83   3            gFlag_1000ms = 0;
  84   3            LED_IO(i); //LEDå…¨äº®æˆ–å…¨ç­
  85   3            i = ~i;
  86   3          }
  87   2          
  88   2        }
  89   1      }
  90          ////////////////////////////////
  91          void externaldevice_IO(unsigned char beepdata,unsigned char relaydata)//IOæ¨¡å¼ï¼Œæ§åˆ¶å¤–éƒ¨è®¾å¤‡ï¼ˆèœ
             -‚é¸£å™¨ã€ç»§ç”µå™¨ï¼‰
  92          {
  93   1        unsigned char extdev_data=0;
  94   1        if(beepdata) extdev_data|=0X40;
  95   1        if(relaydata) extdev_data|=0X10;
  96   1        EA = 0;//å…³é—­ä¸­æ–­æ€»ä½¿èƒ½
  97   1        P0 = extdev_data;
  98   1        P2 = (P2 & 0X1F)|0XA0;//0b 101X XXXX ä½¿138è¯‘ç è¾“å…¥CBAä¸º5ï¼ŒY5è¾“å‡ºä½ç”µå¹³ï¼Œ573çš„LEä¸ºé«˜é”å­
             -˜çŠ¶æ€è§£é™¤
  99   1        P0 = extdev_data;
 100   1        P2 &= 0X1F;//0b 000X XXXX //é”å­˜æ•°æ®
 101   1        EA = 1;//æ‰“å¼€ä¸­æ–­æ€»ä½¿èƒ½
 102   1      }
 103          ////////////////////////////////
 104          void externaldevice_MM(unsigned char beepdata,unsigned char relaydata)//MMæ¨¡å¼ï¼Œæ§åˆ¶å¤–éƒ¨è®¾å¤‡ï¼ˆèœ
             -‚é¸£å™¨ã€ç»§ç”µå™¨ï¼‰
 105          {
 106   1        unsigned char extdev_data=0;
 107   1        if(beepdata) extdev_data|=0X40;
 108   1        if(relaydata) extdev_data|=0X10;
 109   1        EA = 0;//å…³é—­ä¸­æ–­æ€»ä½¿èƒ½
C51 COMPILER V9.54   ________                                                              08/10/2023 18:29:07 PAGE 3   

 110   1        XBYTE[0XA000] = extdev_data;
 111   1        P2 &= 0X1F;//0b 000X XXXX //é”å­˜æ•°æ®
 112   1        EA = 1;//æ‰“å¼€ä¸­æ–­æ€»ä½¿èƒ½
 113   1      }
 114          ////////////////////////////////
 115          void delay_ms(unsigned int delaydata)//å»¶æ—¶å‡½æ•°
 116          {
 117   1        unsigned int i;
 118   1        while(delaydata--)
 119   1          for(i=640;i>0;i--);
 120   1      }
 121          
 122          /////////////////////////////
 123          void LED_IO(unsigned char LEDdata)//IOæ¨¡å¼ï¼Œæ§åˆ¶LED
 124          {
 125   1        
 126   1        EA = 0;//å…³é—­ä¸­æ–­æ€»ä½¿èƒ½
 127   1        P0 = LEDdata;
 128   1        P2 = (P2 & 0X1F)|0X80;//0b 100X XXXX ä½¿138è¯‘ç è¾“å…¥CBAä¸º5ï¼ŒY5è¾“å‡ºä½ç”µå¹³ï¼Œ573çš„LEä¸ºé«˜é”å­
             -˜çŠ¶æ€è§£é™¤
 129   1        P0 = LEDdata;
 130   1        P2 &= 0X1F;//0b 000X XXXX //é”å­˜æ•°æ®
 131   1        EA = 1;//æ‰“å¼€ä¸­æ–­æ€»ä½¿èƒ½
 132   1      }
 133          
 134          void LED_MM(unsigned char LEDdata)//MMæ¨¡å¼ï¼Œæ§åˆ¶LED
 135          {
 136   1        EA = 0;//å…³é—­ä¸­æ–­æ€»ä½¿èƒ½
 137   1        XBYTE[0X8000] = LEDdata;
 138   1        P2 &= 0X1F;//0b 000X XXXX //é”å­˜æ•°æ®
 139   1        EA = 1;//æ‰“å¼€ä¸­æ–­æ€»ä½¿èƒ½
 140   1      }
 141          
 142          /////////////////////////////
 143          void timer1_init(void)         //time1å®šæ—¶è®¡æ•°å™¨é…ç½®ä¸º1msçš„å®šæ—¶ä¸­æ–­
 144          {
 145   1              AUXR &= 0xBF;           //å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 146   1              TMOD &= 0x0F;           //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 147   1              TL1 = 0x18;             //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 148   1              TH1 = 0xFC;             //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 149   1              TF1 = 0;                //æ¸…é™¤TF1æ ‡å¿—
 150   1              TR1 = 1;                //å®šæ—¶å™¨1å¼€å§‹è®¡æ—¶
 151   1        ET1 = 1;        //time1ä¸­æ–­åˆ†å…è®¸
 152   1        EA = 1;         //ä¸­æ–­æ€»å…è®¸
 153   1      }
 154          
 155          void tm1_isr() interrupt 3
 156          {
 157   1        gTimer_1ms++;
 158   1        if(gTimer_1ms == 60000)    gTimer_1ms=0;
 159   1        if(gTimer_1ms%10 == 0)    gFlag_10ms=1;
 160   1        if(gTimer_1ms%50 == 0)    gFlag_50ms=1;
 161   1        if(gTimer_1ms%100 == 0)   gFlag_100ms=1;
 162   1        if(gTimer_1ms%200 == 0)   gFlag_200ms=1;
 163   1        if(gTimer_1ms%250 == 0)   gFlag_250ms=1;
 164   1        if(gTimer_1ms%1000 == 0)  gFlag_1000ms=1;
 165   1        display_IO();
 166   1      }
 167          //////////////////////////////////////////////////
 168          void display_IO(void)
 169          {
 170   1        static unsigned char dispcom_IO = 0;
C51 COMPILER V9.54   ________                                                              08/10/2023 18:29:07 PAGE 4   

 171   1      
 172   1        P0 = 0xFF; //ä½¿æ®µé€‰å…¨éƒ¨è¾“å‡ºä¸ºé«˜ï¼Œä»è€Œä½¿æ‰€æœ‰æ•°ç ç®¡æ¶ˆéš
 173   1        P2 = (P2 & 0x1F)|0XE0;//0b 111X XXXX ä½¿138è¯‘ç è¾“å…¥CBAä¸º7ï¼ŒY7è¾“å‡ºä½ç”µå¹³ï¼Œæ®µé€‰573çš„LEä¸ºé«
             -˜ï¼Œé”å­˜çŠ¶æ€è§£é™¤
 174   1        P2 &= 0x1F;//0b 000X XXXX //é”å­˜æ•°æ®
 175   1        P0 = 0;
 176   1        //ä½é€‰
 177   1        P2 = (P2 & 0X1F)|0XC0;//0b 110X XXXX ä½¿138è¯‘ç è¾“å…¥CBAä¸º6ï¼ŒY6è¾“å‡ºä½ç”µå¹³ï¼Œä½é€‰573çš„LEä¸ºé«
             -˜ï¼Œé”å­˜çŠ¶æ€è§£é™¤
 178   1        P0 = 1<<dispcom_IO;
 179   1        P2 &= 0X1F;//0b 000X XXXX //é”å­˜æ•°æ®
 180   1        //æ®µé€‰
 181   1        P0 = 0xFF;
 182   1        P2 = (P2 & 0X1F)|0XE0;//0b 111X XXXX ä½¿138è¯‘ç è¾“å…¥CBAä¸º7ï¼ŒY7è¾“å‡ºä½ç”µå¹³ï¼Œæ®µé€‰573çš„LEä¸ºé«
             -˜ï¼Œé”å­˜çŠ¶æ€è§£é™¤
 183   1        P0 = ~disptab[dispbuf[dispcom_IO]];
 184   1        P2 &= 0x1F;//0b 000X XXXX //é”å­˜æ•°æ®
 185   1      
 186   1        dispcom_IO++;
 187   1        if (dispcom_IO >= 8) dispcom_IO = 0;
 188   1      }
 189          void display_MM(void)
 190          {
 191   1        EA = 0;//å…³é—­ä¸­æ–­æ€»ä½¿èƒ½
 192   1        XBYTE[0X8000] = 0;
 193   1        P2 &= 0X1F;//0b 000X XXXX //é”å­˜æ•°æ®
 194   1        EA = 1;//æ‰“å¼€ä¸­æ–­æ€»ä½¿èƒ½
 195   1      }
 196          
 197          /////////////////////////////////
 198          unsigned char BTN_KeyBoardScan(void)   //ç‹¬ç«‹æŒ‰é”®æ‰«æç¨‹åºï¼Œæ— æœ‰æ•ˆæŒ‰é”®æŒ‰ä¸‹æ—¶ï¼Œè¿”å›0xFF;
             -æŒ‰é”®æŒ‰ä¸‹ï¼Œè¿”å›å¯¹åº”åºå·ï¼›æŒ‰é”®é•¿æŒ‰æ—¶ï¼Œæ¯è¿‡ä¸€æ®µæ—¶é—´ï¼Œè¿”å›å¯¹åº”åºå·+10ï¼›æ¾æ‰‹æ—¶ï¼Œè¿”å›å¯¹
             -åº”åºå·+20ã€‚
 199          {
 200   1        static unsigned char KeyPressBTN = 0; //å­˜å‚¨æŒ‰é”®æŒ‰å‹æ—¶é•¿
 201   1        static unsigned char KeyFreeBTN = 0;  //æŒ‰é”®æ¾å¼€æ ‡å¿—
 202   1        static unsigned char KeyValueBTN = 0; //å­˜å‚¨æŒ‰é”®é”®å€¼
 203   1        static unsigned char IntervalBTN = 55; //å­˜å‚¨é•¿æŒ‰é”®æ—¶ï¼Œé”®å€¼è¿”å›çš„æ—¶é—´é—´éš”ï¼Œ550ms
 204   1        unsigned char temp;
 205   1        P3 |= 0x0F;
 206   1        temp = (P3 & 0x0F);
 207   1        if(temp != 0x0F) //æ˜¯å¦æœ‰é”®è¢«æŒ‰ä¸‹
 208   1        {
 209   2          if(KeyPressBTN < 200) KeyPressBTN++;
 210   2          if(KeyPressBTN < 5)
 211   2          {
 212   3            return 0xFF;
 213   3          }
 214   2          else if(KeyPressBTN == 5)
 215   2          {
 216   3            KeyFreeBTN = 1;
 217   3            IntervalBTN = 55;
 218   3            switch(temp)
 219   3            {
 220   4              case 0x0E:KeyValueBTN = 7;break;
 221   4              case 0x0D:KeyValueBTN = 6;break;
 222   4              case 0x0B:KeyValueBTN = 5;break;
 223   4              case 0x07:KeyValueBTN = 4;break;
 224   4              //å¦‚æœéœ€è¦ç»„åˆé”®ï¼Œå¯æ ¹æ®é”®å€¼å¢åŠ æƒ…å†µ
 225   4              default:KeyValueBTN = 0xFF; KeyFreeBTN = 0;IntervalBTN = 0;KeyPressBTN = 0;break;
 226   4            }
 227   3            return KeyValueBTN;
C51 COMPILER V9.54   ________                                                              08/10/2023 18:29:07 PAGE 5   

 228   3          }
 229   2          else //å¤„ç†é•¿æŒ‰é”®
 230   2          {
 231   3            if(IntervalBTN)
 232   3            {
 233   4              IntervalBTN--;
 234   4              if(IntervalBTN == 0)
 235   4              {
 236   5                IntervalBTN = 55;
 237   5                return KeyValueBTN+10;
 238   5              }
 239   4            }
 240   3            else IntervalBTN = 55;
 241   3            return 0xFF;
 242   3          }
 243   2        }
 244   1        else //æ— é”®æŒ‰ä¸‹æˆ–å·²é‡Šæ”¾
 245   1        {
 246   2          KeyPressBTN = 0;
 247   2          if(KeyFreeBTN == 1)
 248   2          {
 249   3            KeyFreeBTN = 0;
 250   3            return KeyValueBTN+20;
 251   3          }
 252   2          return 0xFF;
 253   2        }
 254   1      
 255   1      
 256   1      }
*** WARNING C294 IN LINE 70 OF ×¼¿¼Ö¤ºÅ.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    660    ----
   CONSTANT SIZE    =     43    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
